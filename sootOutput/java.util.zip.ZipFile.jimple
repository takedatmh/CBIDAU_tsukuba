public class java.util.zip.ZipFile extends java.lang.Object implements java.util.zip.ZipConstants, java.io.Closeable
{
    private long jzfile;
    private final java.lang.String name;
    private final int total;
    private final boolean locsig;
    private volatile boolean closeRequested;
    private static final int STORED;
    private static final int DEFLATED;
    public static final int OPEN_READ;
    public static final int OPEN_DELETE;
    private static final boolean usemmap;
    private java.util.zip.ZipCoder zc;
    private final java.util.Map streams;
    private java.util.Deque inflaterCache;
    private static final int JZENTRY_NAME;
    private static final int JZENTRY_EXTRA;
    private static final int JZENTRY_COMMENT;

    private static native void initIDs();

    public void <init>(java.lang.String) throws java.io.IOException
    {
        java.util.zip.ZipFile r0;
        java.lang.String r1;
        java.io.File $r2;

        r0 := @this: java.util.zip.ZipFile;
        r1 := @parameter0: java.lang.String;
        $r2 = new java.io.File;
        specialinvoke $r2.<java.io.File: void <init>(java.lang.String)>(r1);
        specialinvoke r0.<java.util.zip.ZipFile: void <init>(java.io.File,int)>($r2, 1);
        return;
    }

    public void <init>(java.io.File, int) throws java.io.IOException
    {
        java.util.zip.ZipFile r0;
        java.io.File r1;
        int i0;
        java.nio.charset.Charset $r2;

        r0 := @this: java.util.zip.ZipFile;
        r1 := @parameter0: java.io.File;
        i0 := @parameter1: int;
        $r2 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset UTF_8>;
        specialinvoke r0.<java.util.zip.ZipFile: void <init>(java.io.File,int,java.nio.charset.Charset)>(r1, i0, $r2);
        return;
    }

    public void <init>(java.io.File) throws java.util.zip.ZipException, java.io.IOException
    {
        java.util.zip.ZipFile r0;
        java.io.File r1;

        r0 := @this: java.util.zip.ZipFile;
        r1 := @parameter0: java.io.File;
        specialinvoke r0.<java.util.zip.ZipFile: void <init>(java.io.File,int)>(r1, 1);
        return;
    }

    public void <init>(java.io.File, int, java.nio.charset.Charset) throws java.io.IOException
    {
        java.util.zip.ZipFile r0;
        java.io.File r1;
        int i0, $i2, $i3, $i4, $i8;
        java.nio.charset.Charset r2;
        java.lang.String r3, $r10, $r12;
        java.lang.SecurityManager r4;
        long l1, $l5, $l6, $l7, $l9;
        boolean $z0, $z1;
        java.util.WeakHashMap $r5;
        java.util.ArrayDeque $r6;
        java.lang.IllegalArgumentException $r7;
        java.lang.StringBuilder $r8, $r9, $r11;
        java.lang.NullPointerException $r13;
        java.util.zip.ZipCoder $r14;
        sun.misc.PerfCounter $r15, $r16;

        r0 := @this: java.util.zip.ZipFile;
        r1 := @parameter0: java.io.File;
        i0 := @parameter1: int;
        r2 := @parameter2: java.nio.charset.Charset;
        specialinvoke r0.<java.lang.Object: void <init>()>();
        r0.<java.util.zip.ZipFile: boolean closeRequested> = 0;
        $r5 = new java.util.WeakHashMap;
        specialinvoke $r5.<java.util.WeakHashMap: void <init>()>();
        r0.<java.util.zip.ZipFile: java.util.Map streams> = $r5;
        $r6 = new java.util.ArrayDeque;
        specialinvoke $r6.<java.util.ArrayDeque: void <init>()>();
        r0.<java.util.zip.ZipFile: java.util.Deque inflaterCache> = $r6;
        $i2 = i0 & 1;
        if $i2 == 0 goto label0;

        $i3 = i0 & -6;
        if $i3 == 0 goto label1;

     label0:
        $r7 = new java.lang.IllegalArgumentException;
        $r8 = new java.lang.StringBuilder;
        specialinvoke $r8.<java.lang.StringBuilder: void <init>()>();
        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Illegal mode: 0x");
        $r10 = staticinvoke <java.lang.Integer: java.lang.String toHexString(int)>(i0);
        $r11 = virtualinvoke $r9.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r10);
        $r12 = virtualinvoke $r11.<java.lang.StringBuilder: java.lang.String toString()>();
        specialinvoke $r7.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($r12);
        throw $r7;

     label1:
        r3 = virtualinvoke r1.<java.io.File: java.lang.String getPath()>();
        r4 = staticinvoke <java.lang.System: java.lang.SecurityManager getSecurityManager()>();
        if r4 == null goto label2;

        virtualinvoke r4.<java.lang.SecurityManager: void checkRead(java.lang.String)>(r3);
        $i4 = i0 & 4;
        if $i4 == 0 goto label2;

        virtualinvoke r4.<java.lang.SecurityManager: void checkDelete(java.lang.String)>(r3);

     label2:
        if r2 != null goto label3;

        $r13 = new java.lang.NullPointerException;
        specialinvoke $r13.<java.lang.NullPointerException: void <init>(java.lang.String)>("charset is null");
        throw $r13;

     label3:
        $r14 = staticinvoke <java.util.zip.ZipCoder: java.util.zip.ZipCoder get(java.nio.charset.Charset)>(r2);
        r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc> = $r14;
        l1 = staticinvoke <java.lang.System: long nanoTime()>();
        $l5 = virtualinvoke r1.<java.io.File: long lastModified()>();
        $z0 = <java.util.zip.ZipFile: boolean usemmap>;
        $l6 = staticinvoke <java.util.zip.ZipFile: long open(java.lang.String,int,long,boolean)>(r3, i0, $l5, $z0);
        r0.<java.util.zip.ZipFile: long jzfile> = $l6;
        $r15 = staticinvoke <sun.misc.PerfCounter: sun.misc.PerfCounter getZipFileOpenTime()>();
        virtualinvoke $r15.<sun.misc.PerfCounter: void addElapsedTimeFrom(long)>(l1);
        $r16 = staticinvoke <sun.misc.PerfCounter: sun.misc.PerfCounter getZipFileCount()>();
        virtualinvoke $r16.<sun.misc.PerfCounter: void increment()>();
        r0.<java.util.zip.ZipFile: java.lang.String name> = r3;
        $l7 = r0.<java.util.zip.ZipFile: long jzfile>;
        $i8 = staticinvoke <java.util.zip.ZipFile: int getTotal(long)>($l7);
        r0.<java.util.zip.ZipFile: int total> = $i8;
        $l9 = r0.<java.util.zip.ZipFile: long jzfile>;
        $z1 = staticinvoke <java.util.zip.ZipFile: boolean startsWithLOC(long)>($l9);
        r0.<java.util.zip.ZipFile: boolean locsig> = $z1;
        return;
    }

    public void <init>(java.lang.String, java.nio.charset.Charset) throws java.io.IOException
    {
        java.util.zip.ZipFile r0;
        java.lang.String r1;
        java.nio.charset.Charset r2;
        java.io.File $r3;

        r0 := @this: java.util.zip.ZipFile;
        r1 := @parameter0: java.lang.String;
        r2 := @parameter1: java.nio.charset.Charset;
        $r3 = new java.io.File;
        specialinvoke $r3.<java.io.File: void <init>(java.lang.String)>(r1);
        specialinvoke r0.<java.util.zip.ZipFile: void <init>(java.io.File,int,java.nio.charset.Charset)>($r3, 1, r2);
        return;
    }

    public void <init>(java.io.File, java.nio.charset.Charset) throws java.io.IOException
    {
        java.util.zip.ZipFile r0;
        java.io.File r1;
        java.nio.charset.Charset r2;

        r0 := @this: java.util.zip.ZipFile;
        r1 := @parameter0: java.io.File;
        r2 := @parameter1: java.nio.charset.Charset;
        specialinvoke r0.<java.util.zip.ZipFile: void <init>(java.io.File,int,java.nio.charset.Charset)>(r1, 1, r2);
        return;
    }

    public java.lang.String getComment()
    {
        java.util.zip.ZipFile r0, r2;
        byte[] r3;
        java.lang.Throwable r4, $r7;
        long $l0;
        null_type $n0;
        java.util.zip.ZipCoder $r5;
        int $i1;
        java.lang.String $r6;

        r0 := @this: java.util.zip.ZipFile;
        r2 = r0;
        entermonitor r0;

     label0:
        specialinvoke r0.<java.util.zip.ZipFile: void ensureOpen()>();
        $l0 = r0.<java.util.zip.ZipFile: long jzfile>;
        r3 = staticinvoke <java.util.zip.ZipFile: byte[] getCommentBytes(long)>($l0);
        if r3 != null goto label2;

        $n0 = null;
        exitmonitor r2;

     label1:
        return $n0;

     label2:
        $r5 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $i1 = lengthof r3;
        $r6 = virtualinvoke $r5.<java.util.zip.ZipCoder: java.lang.String toString(byte[],int)>(r3, $i1);
        exitmonitor r2;

     label3:
        return $r6;

     label4:
        $r7 := @caughtexception;

     label5:
        r4 = $r7;
        exitmonitor r2;

     label6:
        throw r4;

        catch java.lang.Throwable from label0 to label1 with label4;
        catch java.lang.Throwable from label2 to label3 with label4;
        catch java.lang.Throwable from label5 to label6 with label4;
    }

    public java.util.zip.ZipEntry getEntry(java.lang.String)
    {
        java.util.zip.ZipFile r0, r2;
        java.lang.String r1;
        long l0, $l1, l2, $l4;
        java.util.zip.ZipEntry r3;
        java.lang.Throwable r4, $r10;
        java.lang.NullPointerException $r5;
        java.util.zip.ZipCoder $r7;
        byte[] $r8;
        byte $b3;

        r0 := @this: java.util.zip.ZipFile;
        r1 := @parameter0: java.lang.String;
        if r1 != null goto label0;

        $r5 = new java.lang.NullPointerException;
        specialinvoke $r5.<java.lang.NullPointerException: void <init>(java.lang.String)>("name");
        throw $r5;

     label0:
        l0 = 0L;
        r2 = r0;
        entermonitor r0;

     label1:
        specialinvoke r0.<java.util.zip.ZipFile: void ensureOpen()>();
        $l1 = r0.<java.util.zip.ZipFile: long jzfile>;
        $r7 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $r8 = virtualinvoke $r7.<java.util.zip.ZipCoder: byte[] getBytes(java.lang.String)>(r1);
        l2 = staticinvoke <java.util.zip.ZipFile: long getEntry(long,byte[],boolean)>($l1, $r8, 1);
        $b3 = l2 cmp 0L;
        if $b3 == 0 goto label3;

        r3 = specialinvoke r0.<java.util.zip.ZipFile: java.util.zip.ZipEntry getZipEntry(java.lang.String,long)>(r1, l2);
        $l4 = r0.<java.util.zip.ZipFile: long jzfile>;
        staticinvoke <java.util.zip.ZipFile: void freeEntry(long,long)>($l4, l2);
        exitmonitor r2;

     label2:
        return r3;

     label3:
        exitmonitor r2;

     label4:
        goto label8;

     label5:
        $r10 := @caughtexception;

     label6:
        r4 = $r10;
        exitmonitor r2;

     label7:
        throw r4;

     label8:
        return null;

        catch java.lang.Throwable from label1 to label2 with label5;
        catch java.lang.Throwable from label3 to label4 with label5;
        catch java.lang.Throwable from label6 to label7 with label5;
    }

    private static native long getEntry(long, byte[], boolean);

    private static native void freeEntry(long, long);

    public java.io.InputStream getInputStream(java.util.zip.ZipEntry) throws java.io.IOException
    {
        java.util.zip.ZipFile r0, r2;
        java.util.zip.ZipEntry r1;
        long l0, $l3, l4, $l5, $l8, l9;
        null_type n0, $n1;
        java.util.Map r3, r7, $r21, $r22, $r27, $r28;
        java.lang.Throwable r4, r8, r9, $r24, $r30, $r33;
        java.util.zip.Inflater r5;
        java.util.zip.ZipFile$ZipFileInflaterInputStream r6, $r26;
        java.lang.NullPointerException $r10;
        java.util.zip.ZipCoder $r12, $r13, $r16;
        boolean $z0;
        int $i1, $i2, $i7, $i12;
        java.lang.String $r14, $r17;
        byte[] $r15, $r18;
        byte $b6, $b10, $b11;
        java.util.zip.ZipFile$ZipFileInputStream $r19, r20;
        java.util.zip.ZipException $r32;

        r0 := @this: java.util.zip.ZipFile;
        r1 := @parameter0: java.util.zip.ZipEntry;
        if r1 != null goto label0;

        $r10 = new java.lang.NullPointerException;
        specialinvoke $r10.<java.lang.NullPointerException: void <init>(java.lang.String)>("entry");
        throw $r10;

     label0:
        l0 = 0L;
        n0 = null;
        r2 = r0;
        entermonitor r0;

     label1:
        specialinvoke r0.<java.util.zip.ZipFile: void ensureOpen()>();
        $r12 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $z0 = virtualinvoke $r12.<java.util.zip.ZipCoder: boolean isUTF8()>();
        if $z0 != 0 goto label2;

        $i1 = r1.<java.util.zip.ZipEntry: int flag>;
        $i2 = $i1 & 2048;
        if $i2 == 0 goto label2;

        $l3 = r0.<java.util.zip.ZipFile: long jzfile>;
        $r13 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $r14 = r1.<java.util.zip.ZipEntry: java.lang.String name>;
        $r15 = virtualinvoke $r13.<java.util.zip.ZipCoder: byte[] getBytesUTF8(java.lang.String)>($r14);
        l4 = staticinvoke <java.util.zip.ZipFile: long getEntry(long,byte[],boolean)>($l3, $r15, 0);
        goto label3;

     label2:
        $l5 = r0.<java.util.zip.ZipFile: long jzfile>;
        $r16 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $r17 = r1.<java.util.zip.ZipEntry: java.lang.String name>;
        $r18 = virtualinvoke $r16.<java.util.zip.ZipCoder: byte[] getBytes(java.lang.String)>($r17);
        l4 = staticinvoke <java.util.zip.ZipFile: long getEntry(long,byte[],boolean)>($l5, $r18, 0);

     label3:
        $b6 = l4 cmp 0L;
        if $b6 != 0 goto label5;

        $n1 = null;
        exitmonitor r2;

     label4:
        return $n1;

     label5:
        $r19 = new java.util.zip.ZipFile$ZipFileInputStream;
        specialinvoke $r19.<java.util.zip.ZipFile$ZipFileInputStream: void <init>(java.util.zip.ZipFile,long)>(r0, l4);
        r20 = $r19;
        $i7 = staticinvoke <java.util.zip.ZipFile: int getEntryMethod(long)>(l4);
        lookupswitch($i7)
        {
            case 0: goto label6;
            case 8: goto label14;
            default: goto label24;
        };

     label6:
        $r21 = r0.<java.util.zip.ZipFile: java.util.Map streams>;
        r3 = $r21;
        entermonitor $r21;

     label7:
        $r22 = r0.<java.util.zip.ZipFile: java.util.Map streams>;
        interfaceinvoke $r22.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>(r20, null);
        exitmonitor r3;

     label8:
        goto label12;

     label9:
        $r24 := @caughtexception;

     label10:
        r4 = $r24;
        exitmonitor r3;

     label11:
        throw r4;

     label12:
        exitmonitor r2;

     label13:
        return r20;

     label14:
        $l8 = staticinvoke <java.util.zip.ZipFile: long getEntrySize(long)>(l4);
        l9 = $l8 + 2L;
        $b10 = l9 cmp 65536L;
        if $b10 <= 0 goto label15;

        l9 = 8192L;

     label15:
        $b11 = l9 cmp 0L;
        if $b11 > 0 goto label16;

        l9 = 4096L;

     label16:
        r5 = specialinvoke r0.<java.util.zip.ZipFile: java.util.zip.Inflater getInflater()>();
        $r26 = new java.util.zip.ZipFile$ZipFileInflaterInputStream;
        $i12 = (int) l9;
        specialinvoke $r26.<java.util.zip.ZipFile$ZipFileInflaterInputStream: void <init>(java.util.zip.ZipFile,java.util.zip.ZipFile$ZipFileInputStream,java.util.zip.Inflater,int)>(r0, r20, r5, $i12);
        r6 = $r26;
        $r27 = r0.<java.util.zip.ZipFile: java.util.Map streams>;
        r7 = $r27;
        entermonitor $r27;

     label17:
        $r28 = r0.<java.util.zip.ZipFile: java.util.Map streams>;
        interfaceinvoke $r28.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>(r6, r5);
        exitmonitor r7;

     label18:
        goto label22;

     label19:
        $r30 := @caughtexception;

     label20:
        r8 = $r30;
        exitmonitor r7;

     label21:
        throw r8;

     label22:
        exitmonitor r2;

     label23:
        return r6;

     label24:
        $r32 = new java.util.zip.ZipException;
        specialinvoke $r32.<java.util.zip.ZipException: void <init>(java.lang.String)>("invalid compression method");
        throw $r32;

     label25:
        $r33 := @caughtexception;
        r9 = $r33;
        exitmonitor r2;

     label26:
        throw r9;

        catch java.lang.Throwable from label7 to label8 with label9;
        catch java.lang.Throwable from label10 to label11 with label9;
        catch java.lang.Throwable from label17 to label18 with label19;
        catch java.lang.Throwable from label20 to label21 with label19;
        catch java.lang.Throwable from label1 to label4 with label25;
        catch java.lang.Throwable from label5 to label13 with label25;
        catch java.lang.Throwable from label14 to label23 with label25;
        catch java.lang.Throwable from label24 to label26 with label25;
    }

    private java.util.zip.Inflater getInflater()
    {
        java.util.zip.ZipFile r0;
        java.util.Deque r1, $r4, $r5;
        java.util.zip.Inflater r2, $r7, $r10;
        java.lang.Throwable r3, $r9;
        java.lang.Object $r6;
        boolean $z0;

        r0 := @this: java.util.zip.ZipFile;
        $r4 = r0.<java.util.zip.ZipFile: java.util.Deque inflaterCache>;
        r1 = $r4;
        entermonitor $r4;

     label0:
        $r5 = r0.<java.util.zip.ZipFile: java.util.Deque inflaterCache>;
        $r6 = interfaceinvoke $r5.<java.util.Deque: java.lang.Object poll()>();
        $r7 = (java.util.zip.Inflater) $r6;
        r2 = $r7;
        if null == $r7 goto label2;

        $z0 = virtualinvoke r2.<java.util.zip.Inflater: boolean ended()>();
        if 0 != $z0 goto label0;

        exitmonitor r1;

     label1:
        return r2;

     label2:
        exitmonitor r1;

     label3:
        goto label7;

     label4:
        $r9 := @caughtexception;

     label5:
        r3 = $r9;
        exitmonitor r1;

     label6:
        throw r3;

     label7:
        $r10 = new java.util.zip.Inflater;
        specialinvoke $r10.<java.util.zip.Inflater: void <init>(boolean)>(1);
        return $r10;

        catch java.lang.Throwable from label0 to label1 with label4;
        catch java.lang.Throwable from label2 to label3 with label4;
        catch java.lang.Throwable from label5 to label6 with label4;
    }

    private void releaseInflater(java.util.zip.Inflater)
    {
        java.util.zip.ZipFile r0;
        java.util.zip.Inflater r1;
        java.util.Deque r2, $r4, $r5;
        java.lang.Throwable r3, $r6;
        boolean $z0;

        r0 := @this: java.util.zip.ZipFile;
        r1 := @parameter0: java.util.zip.Inflater;
        $z0 = virtualinvoke r1.<java.util.zip.Inflater: boolean ended()>();
        if 0 != $z0 goto label5;

        virtualinvoke r1.<java.util.zip.Inflater: void reset()>();
        $r4 = r0.<java.util.zip.ZipFile: java.util.Deque inflaterCache>;
        r2 = $r4;
        entermonitor $r4;

     label0:
        $r5 = r0.<java.util.zip.ZipFile: java.util.Deque inflaterCache>;
        interfaceinvoke $r5.<java.util.Deque: boolean add(java.lang.Object)>(r1);
        exitmonitor r2;

     label1:
        goto label5;

     label2:
        $r6 := @caughtexception;

     label3:
        r3 = $r6;
        exitmonitor r2;

     label4:
        throw r3;

     label5:
        return;

        catch java.lang.Throwable from label0 to label1 with label2;
        catch java.lang.Throwable from label3 to label4 with label2;
    }

    public java.lang.String getName()
    {
        java.util.zip.ZipFile r0;
        java.lang.String $r1;

        r0 := @this: java.util.zip.ZipFile;
        $r1 = r0.<java.util.zip.ZipFile: java.lang.String name>;
        return $r1;
    }

    public java.util.Enumeration entries()
    {
        java.util.zip.ZipFile r0;
        java.util.zip.ZipFile$1 $r1;

        r0 := @this: java.util.zip.ZipFile;
        specialinvoke r0.<java.util.zip.ZipFile: void ensureOpen()>();
        $r1 = new java.util.zip.ZipFile$1;
        specialinvoke $r1.<java.util.zip.ZipFile$1: void <init>(java.util.zip.ZipFile)>(r0);
        return $r1;
    }

    private java.util.zip.ZipEntry getZipEntry(java.lang.String, long)
    {
        java.util.zip.ZipFile r0;
        java.lang.String r1, $r7, $r9, $r14, $r16;
        long l0, $l6, $l7, $l8, $l9;
        java.util.zip.ZipEntry $r2, r3;
        byte[] r4, $r10, r11;
        int $i1, $i2, $i3, $i4, $i5, $i10, $i11, $i12, $i13, $i14;
        java.util.zip.ZipCoder $r5, $r6, $r8, $r12, $r13, $r15;
        boolean $z0, $z1;

        r0 := @this: java.util.zip.ZipFile;
        r1 := @parameter0: java.lang.String;
        l0 := @parameter1: long;
        $r2 = new java.util.zip.ZipEntry;
        specialinvoke $r2.<java.util.zip.ZipEntry: void <init>()>();
        r3 = $r2;
        $i1 = staticinvoke <java.util.zip.ZipFile: int getEntryFlag(long)>(l0);
        r3.<java.util.zip.ZipEntry: int flag> = $i1;
        if r1 == null goto label0;

        r3.<java.util.zip.ZipEntry: java.lang.String name> = r1;
        goto label2;

     label0:
        r4 = staticinvoke <java.util.zip.ZipFile: byte[] getEntryBytes(long,int)>(l0, 0);
        $r5 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $z0 = virtualinvoke $r5.<java.util.zip.ZipCoder: boolean isUTF8()>();
        if $z0 != 0 goto label1;

        $i2 = r3.<java.util.zip.ZipEntry: int flag>;
        $i3 = $i2 & 2048;
        if $i3 == 0 goto label1;

        $r6 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $i4 = lengthof r4;
        $r7 = virtualinvoke $r6.<java.util.zip.ZipCoder: java.lang.String toStringUTF8(byte[],int)>(r4, $i4);
        r3.<java.util.zip.ZipEntry: java.lang.String name> = $r7;
        goto label2;

     label1:
        $r8 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $i5 = lengthof r4;
        $r9 = virtualinvoke $r8.<java.util.zip.ZipCoder: java.lang.String toString(byte[],int)>(r4, $i5);
        r3.<java.util.zip.ZipEntry: java.lang.String name> = $r9;

     label2:
        $l6 = staticinvoke <java.util.zip.ZipFile: long getEntryTime(long)>(l0);
        r3.<java.util.zip.ZipEntry: long time> = $l6;
        $l7 = staticinvoke <java.util.zip.ZipFile: long getEntryCrc(long)>(l0);
        r3.<java.util.zip.ZipEntry: long crc> = $l7;
        $l8 = staticinvoke <java.util.zip.ZipFile: long getEntrySize(long)>(l0);
        r3.<java.util.zip.ZipEntry: long size> = $l8;
        $l9 = staticinvoke <java.util.zip.ZipFile: long getEntryCSize(long)>(l0);
        r3.<java.util.zip.ZipEntry: long csize> = $l9;
        $i10 = staticinvoke <java.util.zip.ZipFile: int getEntryMethod(long)>(l0);
        r3.<java.util.zip.ZipEntry: int method> = $i10;
        $r10 = staticinvoke <java.util.zip.ZipFile: byte[] getEntryBytes(long,int)>(l0, 1);
        r3.<java.util.zip.ZipEntry: byte[] extra> = $r10;
        r11 = staticinvoke <java.util.zip.ZipFile: byte[] getEntryBytes(long,int)>(l0, 2);
        if r11 != null goto label3;

        r3.<java.util.zip.ZipEntry: java.lang.String comment> = null;
        goto label5;

     label3:
        $r12 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $z1 = virtualinvoke $r12.<java.util.zip.ZipCoder: boolean isUTF8()>();
        if $z1 != 0 goto label4;

        $i11 = r3.<java.util.zip.ZipEntry: int flag>;
        $i12 = $i11 & 2048;
        if $i12 == 0 goto label4;

        $r13 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $i13 = lengthof r11;
        $r14 = virtualinvoke $r13.<java.util.zip.ZipCoder: java.lang.String toStringUTF8(byte[],int)>(r11, $i13);
        r3.<java.util.zip.ZipEntry: java.lang.String comment> = $r14;
        goto label5;

     label4:
        $r15 = r0.<java.util.zip.ZipFile: java.util.zip.ZipCoder zc>;
        $i14 = lengthof r11;
        $r16 = virtualinvoke $r15.<java.util.zip.ZipCoder: java.lang.String toString(byte[],int)>(r11, $i14);
        r3.<java.util.zip.ZipEntry: java.lang.String comment> = $r16;

     label5:
        return r3;
    }

    private static native long getNextEntry(long, int);

    public int size()
    {
        java.util.zip.ZipFile r0;
        int $i0;

        r0 := @this: java.util.zip.ZipFile;
        specialinvoke r0.<java.util.zip.ZipFile: void ensureOpen()>();
        $i0 = r0.<java.util.zip.ZipFile: int total>;
        return $i0;
    }

    public void close() throws java.io.IOException
    {
        java.util.zip.ZipFile r0, r1;
        java.util.Map r2, $r11, $r12, $r14, $r15;
        java.util.HashMap r3, $r13;
        java.util.Iterator r4;
        java.util.Map$Entry r5;
        java.util.zip.Inflater r6, $r26, r27;
        java.lang.Throwable r7, r8, r9, $r21, $r28, $r29;
        boolean $z0, $z1, $z2;
        java.util.Set $r16;
        java.lang.Object $r17, $r18, $r20, $r25;
        java.io.InputStream $r19;
        java.util.Deque $r22, r23, $r24;
        long $l0, l2;
        byte $b1;

        r0 := @this: java.util.zip.ZipFile;
        $z0 = r0.<java.util.zip.ZipFile: boolean closeRequested>;
        if $z0 == 0 goto label0;

        return;

     label0:
        r0.<java.util.zip.ZipFile: boolean closeRequested> = 1;
        r1 = r0;
        entermonitor r0;

     label1:
        $r11 = r0.<java.util.zip.ZipFile: java.util.Map streams>;
        r2 = $r11;
        entermonitor $r11;

     label2:
        $r12 = r0.<java.util.zip.ZipFile: java.util.Map streams>;
        $z1 = interfaceinvoke $r12.<java.util.Map: boolean isEmpty()>();
        if 0 != $z1 goto label5;

        $r13 = new java.util.HashMap;
        $r14 = r0.<java.util.zip.ZipFile: java.util.Map streams>;
        specialinvoke $r13.<java.util.HashMap: void <init>(java.util.Map)>($r14);
        r3 = $r13;
        $r15 = r0.<java.util.zip.ZipFile: java.util.Map streams>;
        interfaceinvoke $r15.<java.util.Map: void clear()>();
        $r16 = interfaceinvoke r3.<java.util.Map: java.util.Set entrySet()>();
        r4 = interfaceinvoke $r16.<java.util.Set: java.util.Iterator iterator()>();

     label3:
        $z2 = interfaceinvoke r4.<java.util.Iterator: boolean hasNext()>();
        if $z2 == 0 goto label5;

        $r17 = interfaceinvoke r4.<java.util.Iterator: java.lang.Object next()>();
        r5 = (java.util.Map$Entry) $r17;
        $r18 = interfaceinvoke r5.<java.util.Map$Entry: java.lang.Object getKey()>();
        $r19 = (java.io.InputStream) $r18;
        virtualinvoke $r19.<java.io.InputStream: void close()>();
        $r20 = interfaceinvoke r5.<java.util.Map$Entry: java.lang.Object getValue()>();
        r6 = (java.util.zip.Inflater) $r20;
        if r6 == null goto label4;

        virtualinvoke r6.<java.util.zip.Inflater: void end()>();

     label4:
        goto label3;

     label5:
        exitmonitor r2;

     label6:
        goto label10;

     label7:
        $r21 := @caughtexception;

     label8:
        r7 = $r21;
        exitmonitor r2;

     label9:
        throw r7;

     label10:
        $r22 = r0.<java.util.zip.ZipFile: java.util.Deque inflaterCache>;
        r23 = $r22;
        entermonitor $r22;

     label11:
        $r24 = r0.<java.util.zip.ZipFile: java.util.Deque inflaterCache>;
        $r25 = interfaceinvoke $r24.<java.util.Deque: java.lang.Object poll()>();
        $r26 = (java.util.zip.Inflater) $r25;
        r27 = $r26;
        if null == $r26 goto label12;

        virtualinvoke r27.<java.util.zip.Inflater: void end()>();
        goto label11;

     label12:
        exitmonitor r23;

     label13:
        goto label17;

     label14:
        $r28 := @caughtexception;

     label15:
        r8 = $r28;
        exitmonitor r23;

     label16:
        throw r8;

     label17:
        $l0 = r0.<java.util.zip.ZipFile: long jzfile>;
        $b1 = $l0 cmp 0L;
        if $b1 == 0 goto label18;

        l2 = r0.<java.util.zip.ZipFile: long jzfile>;
        r0.<java.util.zip.ZipFile: long jzfile> = 0L;
        staticinvoke <java.util.zip.ZipFile: void close(long)>(l2);

     label18:
        exitmonitor r1;

     label19:
        goto label23;

     label20:
        $r29 := @caughtexception;

     label21:
        r9 = $r29;
        exitmonitor r1;

     label22:
        throw r9;

     label23:
        return;

        catch java.lang.Throwable from label2 to label6 with label7;
        catch java.lang.Throwable from label8 to label9 with label7;
        catch java.lang.Throwable from label11 to label13 with label14;
        catch java.lang.Throwable from label15 to label16 with label14;
        catch java.lang.Throwable from label1 to label19 with label20;
        catch java.lang.Throwable from label21 to label22 with label20;
    }

    protected void finalize() throws java.io.IOException
    {
        java.util.zip.ZipFile r0;

        r0 := @this: java.util.zip.ZipFile;
        virtualinvoke r0.<java.util.zip.ZipFile: void close()>();
        return;
    }

    private static native void close(long);

    private void ensureOpen()
    {
        java.util.zip.ZipFile r0;
        boolean $z0;
        java.lang.IllegalStateException $r1, $r2;
        long $l0;
        byte $b1;

        r0 := @this: java.util.zip.ZipFile;
        $z0 = r0.<java.util.zip.ZipFile: boolean closeRequested>;
        if $z0 == 0 goto label0;

        $r1 = new java.lang.IllegalStateException;
        specialinvoke $r1.<java.lang.IllegalStateException: void <init>(java.lang.String)>("zip file closed");
        throw $r1;

     label0:
        $l0 = r0.<java.util.zip.ZipFile: long jzfile>;
        $b1 = $l0 cmp 0L;
        if $b1 != 0 goto label1;

        $r2 = new java.lang.IllegalStateException;
        specialinvoke $r2.<java.lang.IllegalStateException: void <init>(java.lang.String)>("The object is not initialized.");
        throw $r2;

     label1:
        return;
    }

    private void ensureOpenOrZipException() throws java.io.IOException
    {
        java.util.zip.ZipFile r0;
        boolean $z0;
        java.util.zip.ZipException $r1;

        r0 := @this: java.util.zip.ZipFile;
        $z0 = r0.<java.util.zip.ZipFile: boolean closeRequested>;
        if $z0 == 0 goto label0;

        $r1 = new java.util.zip.ZipException;
        specialinvoke $r1.<java.util.zip.ZipException: void <init>(java.lang.String)>("ZipFile closed");
        throw $r1;

     label0:
        return;
    }

    private boolean startsWithLocHeader()
    {
        java.util.zip.ZipFile r0;
        boolean $z0;

        r0 := @this: java.util.zip.ZipFile;
        $z0 = r0.<java.util.zip.ZipFile: boolean locsig>;
        return $z0;
    }

    private static native long open(java.lang.String, int, long, boolean) throws java.io.IOException;

    private static native int getTotal(long);

    private static native boolean startsWithLOC(long);

    private static native int read(long, long, long, byte[], int, int);

    private static native long getEntryTime(long);

    private static native long getEntryCrc(long);

    private static native long getEntryCSize(long);

    private static native long getEntrySize(long);

    private static native int getEntryMethod(long);

    private static native int getEntryFlag(long);

    private static native byte[] getCommentBytes(long);

    private static native byte[] getEntryBytes(long, int);

    private static native java.lang.String getZipMessage(long);

    static java.util.Map access$000(java.util.zip.ZipFile)
    {
        java.util.zip.ZipFile r0;
        java.util.Map $r1;

        r0 := @parameter0: java.util.zip.ZipFile;
        $r1 = r0.<java.util.zip.ZipFile: java.util.Map streams>;
        return $r1;
    }

    static void access$100(java.util.zip.ZipFile, java.util.zip.Inflater)
    {
        java.util.zip.ZipFile r0;
        java.util.zip.Inflater r1;

        r0 := @parameter0: java.util.zip.ZipFile;
        r1 := @parameter1: java.util.zip.Inflater;
        specialinvoke r0.<java.util.zip.ZipFile: void releaseInflater(java.util.zip.Inflater)>(r1);
        return;
    }

    static void access$200(java.util.zip.ZipFile)
    {
        java.util.zip.ZipFile r0;

        r0 := @parameter0: java.util.zip.ZipFile;
        specialinvoke r0.<java.util.zip.ZipFile: void ensureOpen()>();
        return;
    }

    static int access$300(java.util.zip.ZipFile)
    {
        java.util.zip.ZipFile r0;
        int $i0;

        r0 := @parameter0: java.util.zip.ZipFile;
        $i0 = r0.<java.util.zip.ZipFile: int total>;
        return $i0;
    }

    static long access$400(java.util.zip.ZipFile)
    {
        java.util.zip.ZipFile r0;
        long $l0;

        r0 := @parameter0: java.util.zip.ZipFile;
        $l0 = r0.<java.util.zip.ZipFile: long jzfile>;
        return $l0;
    }

    static long access$500(long, int)
    {
        long l0, $l2;
        int i1;

        l0 := @parameter0: long;
        i1 := @parameter1: int;
        $l2 = staticinvoke <java.util.zip.ZipFile: long getNextEntry(long,int)>(l0, i1);
        return $l2;
    }

    static boolean access$600(java.util.zip.ZipFile)
    {
        java.util.zip.ZipFile r0;
        boolean $z0;

        r0 := @parameter0: java.util.zip.ZipFile;
        $z0 = r0.<java.util.zip.ZipFile: boolean closeRequested>;
        return $z0;
    }

    static java.lang.String access$700(long)
    {
        long l0;
        java.lang.String $r0;

        l0 := @parameter0: long;
        $r0 = staticinvoke <java.util.zip.ZipFile: java.lang.String getZipMessage(long)>(l0);
        return $r0;
    }

    static java.lang.String access$800(java.util.zip.ZipFile)
    {
        java.util.zip.ZipFile r0;
        java.lang.String $r1;

        r0 := @parameter0: java.util.zip.ZipFile;
        $r1 = r0.<java.util.zip.ZipFile: java.lang.String name>;
        return $r1;
    }

    static java.util.zip.ZipEntry access$900(java.util.zip.ZipFile, java.lang.String, long)
    {
        java.util.zip.ZipFile r0;
        java.lang.String r1;
        long l0;
        java.util.zip.ZipEntry $r2;

        r0 := @parameter0: java.util.zip.ZipFile;
        r1 := @parameter1: java.lang.String;
        l0 := @parameter2: long;
        $r2 = specialinvoke r0.<java.util.zip.ZipFile: java.util.zip.ZipEntry getZipEntry(java.lang.String,long)>(r1, l0);
        return $r2;
    }

    static void access$1000(long, long)
    {
        long l0, l1;

        l0 := @parameter0: long;
        l1 := @parameter1: long;
        staticinvoke <java.util.zip.ZipFile: void freeEntry(long,long)>(l0, l1);
        return;
    }

    static long access$1100(long)
    {
        long l0, $l1;

        l0 := @parameter0: long;
        $l1 = staticinvoke <java.util.zip.ZipFile: long getEntryCSize(long)>(l0);
        return $l1;
    }

    static long access$1200(long)
    {
        long l0, $l1;

        l0 := @parameter0: long;
        $l1 = staticinvoke <java.util.zip.ZipFile: long getEntrySize(long)>(l0);
        return $l1;
    }

    static void access$1300(java.util.zip.ZipFile) throws java.io.IOException
    {
        java.util.zip.ZipFile r0;

        r0 := @parameter0: java.util.zip.ZipFile;
        specialinvoke r0.<java.util.zip.ZipFile: void ensureOpenOrZipException()>();
        return;
    }

    static int access$1400(long, long, long, byte[], int, int)
    {
        long l0, l1, l2;
        byte[] r0;
        int i3, i4, $i5;

        l0 := @parameter0: long;
        l1 := @parameter1: long;
        l2 := @parameter2: long;
        r0 := @parameter3: byte[];
        i3 := @parameter4: int;
        i4 := @parameter5: int;
        $i5 = staticinvoke <java.util.zip.ZipFile: int read(long,long,long,byte[],int,int)>(l0, l1, l2, r0, i3, i4);
        return $i5;
    }

    static boolean access$1500(java.util.zip.ZipFile)
    {
        java.util.zip.ZipFile r0;
        boolean $z0;

        r0 := @parameter0: java.util.zip.ZipFile;
        $z0 = specialinvoke r0.<java.util.zip.ZipFile: boolean startsWithLocHeader()>();
        return $z0;
    }

    static void <clinit>()
    {
        java.lang.String r0;
        int $i0;
        boolean $z0, $z1;
        java.util.zip.ZipFile$2 $r1;

        staticinvoke <java.util.zip.ZipFile: void initIDs()>();
        r0 = staticinvoke <sun.misc.VM: java.lang.String getSavedProperty(java.lang.String)>("sun.zip.disableMemoryMapping");
        if r0 == null goto label0;

        $i0 = virtualinvoke r0.<java.lang.String: int length()>();
        if $i0 == 0 goto label1;

        $z0 = virtualinvoke r0.<java.lang.String: boolean equalsIgnoreCase(java.lang.String)>("true");
        if $z0 != 0 goto label1;

     label0:
        $z1 = 1;
        goto label2;

     label1:
        $z1 = 0;

     label2:
        <java.util.zip.ZipFile: boolean usemmap> = $z1;
        $r1 = new java.util.zip.ZipFile$2;
        specialinvoke $r1.<java.util.zip.ZipFile$2: void <init>()>();
        staticinvoke <sun.misc.SharedSecrets: void setJavaUtilZipFileAccess(sun.misc.JavaUtilZipFileAccess)>($r1);
        return;
    }
}
